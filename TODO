- qcd/fermion/operator needs to inherit from matrix_operator with action w.M.
  This then allows for a much cleaner interface as inverters will take matrix_operators
  as input but input can also define more structure that can be used in preconditioning.

- Long-term strategy needs to be to get rid of qcd/fermion/solvers directory.  Everything
  in here needs to be put on same footing as inverters in algorithms directory.

- New femrion/operator . propagator function

- algorithms.iterative / algorithms.approx structure is not ideal.  Better structure
  it by logic of algorihtms:

  - solvers

  - polynomials

  - eigen (eigenvector/value finders)

  - modes (do something with modes, LMA/A2A, ...)

- All inverters need to follow the __init__/__call__ interface:
  s = solver(solver_params)
  inverse_matrix = s(matrix)

- SAP fits perfectly in defect_correcting solver form and should just be a preconditioner
  generating the approximation matrix K of the Luscher paper.

- Transpose for singlet_rank == 2:
  There is missing code in

   https://github.com/lehner/gpt/blob/master/lib/cgpt/lib/eval.cc

  at lines 218 and 231 to appropriately shuffle the indices of a versus dst.
  This is where it should be handled.  Adj should only set the trans|conj
  flags for the expression engine.

- On MG branch: t=timer(); t("block1"); block1; t("block2"); block2; t(); g.message(t); <-- use timer __str__ and __c
all__, can also do t("block1", bytes = bytes_processed, flops = flops_in_block) to add GB/s and Gflops/s

- Grid-production-code/zmobius_2pt_hvp_con_gstore/Fourier... <-- First TM, then 5d TM, then  FA

- test applications on summit with new version + new Grid

- A2A meson fields

- Using the l[...] interface, I could implement in python a stencil!  This may still
  be somewhat slower than the C++ operators but should be worth it for slightly less
  performance-critical code.

- Stout smearing, plaquette implementation using covariant shifts

- Complete sparse/split grid implementation

- Add RLE capable convertor to cgpt from coordinates to different
  linear orders

- Based on this implement in python a parallel reader for file formats nerscIO, openQCD

- sources

- verbose=eval -> Bytes/s & Flops/s for expression evaluation
